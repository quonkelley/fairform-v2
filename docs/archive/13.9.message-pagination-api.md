# Story 13.9: Message Pagination API

## Status
Draft

## Story
**As a** FairForm developer,
**I want** efficient message pagination API endpoints,
**so that** chat history can be loaded incrementally without performance issues.

## Acceptance Criteria

1. API endpoint supports cursor-based pagination for messages
2. Endpoint returns messages in reverse chronological order (newest first)
3. Pagination uses timestamp-based cursors for consistent ordering
4. API includes hasMore flag and nextCursor for client navigation
5. Endpoint supports filtering by session and date range
6. API handles large message histories efficiently
7. Endpoint includes proper error handling and validation
8. Integration tests cover pagination edge cases

## Tasks / Subtasks

- [ ] Task 1: Create pagination API endpoint (AC: 1, 2)
  - [ ] Create `app/api/ai/copilot/messages/route.ts`
  - [ ] Implement GET handler with query parameters
  - [ ] Add cursor-based pagination logic
  - [ ] Return messages in reverse chronological order
  - [ ] Add proper response formatting

- [ ] Task 2: Implement cursor-based pagination (AC: 3, 4)
  - [ ] Use createdAt timestamp as cursor
  - [ ] Implement cursor validation and parsing
  - [ ] Add hasMore calculation logic
  - [ ] Generate nextCursor for client use
  - [ ] Handle cursor edge cases (first/last page)

- [ ] Task 3: Add query parameter validation (AC: 5, 7)
  - [ ] Validate sessionId parameter (required)
  - [ ] Validate limit parameter (default 20, max 100)
  - [ ] Validate cursor parameter (optional timestamp)
  - [ ] Add date range filtering support
  - [ ] Return validation errors with proper status codes

- [ ] Task 4: Implement efficient database queries (AC: 6)
  - [ ] Use Firestore composite indexes for performance
  - [ ] Implement proper ordering and limiting
  - [ ] Add query optimization for large datasets
  - [ ] Handle database timeout scenarios
  - [ ] Add query performance logging

- [ ] Task 5: Add comprehensive error handling (AC: 7)
  - [ ] Handle invalid session IDs
  - [ ] Handle malformed cursor values
  - [ ] Handle database connection errors
  - [ ] Return appropriate HTTP status codes
  - [ ] Add error logging for debugging

- [ ] Task 6: Implement response formatting (AC: 4)
  - [ ] Format messages with proper structure
  - [ ] Include pagination metadata
  - [ ] Add response headers for caching
  - [ ] Include total count when available
  - [ ] Add request/response logging

- [ ] Task 7: Add integration with existing repos (AC: 1)
  - [ ] Use aiSessionsRepo for message retrieval
  - [ ] Integrate with session validation
  - [ ] Add authentication checks
  - [ ] Handle demo mode appropriately
  - [ ] Maintain consistency with other APIs

- [ ] Task 8: Create comprehensive tests (AC: 8)
  - [ ] Test pagination with various cursor values
  - [ ] Test edge cases (empty results, single page)
  - [ ] Test error scenarios (invalid session, malformed cursor)
  - [ ] Test performance with large datasets
  - [ ] Mock Firestore for isolated testing

## Dev Notes

### Architecture Context
[Source: docs/epic-13-unified-architecture-specification.md]

Message pagination is essential for **performance and user experience**. The API uses **cursor-based pagination** with timestamps for consistent ordering and efficient database queries.

**Key Design Decisions:**
- Cursor-based pagination (not offset-based)
- Reverse chronological ordering (newest first)
- Timestamp cursors for consistency
- Efficient Firestore queries with indexes
- Comprehensive error handling

### API Contract

**Endpoint:** `GET /api/ai/copilot/messages`

**Query Parameters:**
```typescript
interface MessagesQuery {
  sessionId: string;        // Required: Session ID
  limit?: number;          // Optional: Max messages (default 20, max 100)
  cursor?: string;         // Optional: Timestamp cursor for pagination
  before?: string;         // Optional: ISO date string for date filtering
  after?: string;          // Optional: ISO date string for date filtering
}
```

**Response Format:**
```typescript
interface MessagesResponse {
  items: AIMessage[];      // Array of messages
  pagination: {
    hasMore: boolean;      // Whether more messages exist
    nextCursor?: string;   // Cursor for next page
    totalCount?: number;   // Total messages (if available)
  };
  meta: {
    sessionId: string;     // Session ID
    requestedAt: number;   // Timestamp of request
    queryTime: number;     // Database query time in ms
  };
}
```

### Cursor-Based Pagination

**Cursor Implementation:**
```typescript
interface PaginationCursor {
  timestamp: number;       // Message createdAt timestamp
  messageId: string;       // Message ID for uniqueness
}

function encodeCursor(cursor: PaginationCursor): string {
  return Buffer.from(JSON.stringify(cursor)).toString('base64');
}

function decodeCursor(cursorString: string): PaginationCursor | null {
  try {
    const decoded = Buffer.from(cursorString, 'base64').toString('utf-8');
    return JSON.parse(decoded);
  } catch {
    return null;
  }
}
```

**Pagination Logic:**
```typescript
async function getMessagesWithPagination(
  sessionId: string,
  limit: number = 20,
  cursor?: string
): Promise<MessagesResponse> {
  const startTime = Date.now();
  
  // Decode cursor if provided
  const paginationCursor = cursor ? decodeCursor(cursor) : null;
  
  if (cursor && !paginationCursor) {
    throw new Error('Invalid cursor format');
  }
  
  // Build Firestore query
  let query = db
    .collection('aiSessions')
    .doc(sessionId)
    .collection('messages')
    .orderBy('createdAt', 'desc')
    .limit(limit + 1); // Fetch one extra to check hasMore
  
  // Apply cursor filter
  if (paginationCursor) {
    query = query.startAfter(paginationCursor.timestamp, paginationCursor.messageId);
  }
  
  const snapshot = await query.get();
  const messages = snapshot.docs.map(doc => ({
    id: doc.id,
    ...doc.data()
  })) as AIMessage[];
  
  // Check if there are more messages
  const hasMore = messages.length > limit;
  const items = hasMore ? messages.slice(0, limit) : messages;
  
  // Generate next cursor
  let nextCursor: string | undefined;
  if (hasMore && items.length > 0) {
    const lastMessage = items[items.length - 1];
    nextCursor = encodeCursor({
      timestamp: lastMessage.createdAt,
      messageId: lastMessage.id
    });
  }
  
  return {
    items,
    pagination: {
      hasMore,
      nextCursor,
      totalCount: undefined // Not calculated for performance
    },
    meta: {
      sessionId,
      requestedAt: Date.now(),
      queryTime: Date.now() - startTime
    }
  };
}
```

### API Route Implementation

**Route Handler:**
```typescript
// app/api/ai/copilot/messages/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { requireAuth } from '@/lib/auth/server-auth';
import { getMessagesWithPagination } from '@/lib/ai/pagination';
import { MessagesQuerySchema } from '@/lib/ai/schemas';

export async function GET(request: NextRequest) {
  try {
    // Authentication check
    const user = await requireAuth(request);
    
    // Parse and validate query parameters
    const { searchParams } = new URL(request.url);
    const queryParams = {
      sessionId: searchParams.get('sessionId'),
      limit: searchParams.get('limit'),
      cursor: searchParams.get('cursor'),
      before: searchParams.get('before'),
      after: searchParams.get('after')
    };
    
    const validatedQuery = MessagesQuerySchema.parse(queryParams);
    
    // Get messages with pagination
    const result = await getMessagesWithPagination(
      validatedQuery.sessionId,
      validatedQuery.limit,
      validatedQuery.cursor
    );
    
    // Apply date filtering if specified
    if (validatedQuery.before || validatedQuery.after) {
      result.items = result.items.filter(message => {
        const messageDate = new Date(message.createdAt);
        
        if (validatedQuery.after && messageDate < new Date(validatedQuery.after)) {
          return false;
        }
        
        if (validatedQuery.before && messageDate > new Date(validatedQuery.before)) {
          return false;
        }
        
        return true;
      });
    }
    
    // Set cache headers
    const response = NextResponse.json(result);
    response.headers.set('Cache-Control', 'private, max-age=60'); // 1 minute cache
    
    return response;
    
  } catch (error) {
    console.error('Messages API error:', error);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid query parameters', details: error.errors },
        { status: 400 }
      );
    }
    
    if (error.message === 'Invalid cursor format') {
      return NextResponse.json(
        { error: 'Invalid cursor format' },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Query Parameter Validation

**Zod Schema:**
```typescript
// lib/ai/schemas.ts
export const MessagesQuerySchema = z.object({
  sessionId: z.string().min(1, 'Session ID is required'),
  limit: z.coerce.number().min(1).max(100).default(20),
  cursor: z.string().optional(),
  before: z.string().datetime().optional(),
  after: z.string().datetime().optional()
});
```

### Firestore Indexes

**Required Composite Indexes:**
```javascript
// firestore.indexes.json
{
  "indexes": [
    {
      "collectionGroup": "messages",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "sessionId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "createdAt",
          "order": "DESCENDING"
        }
      ]
    }
  ]
}
```

### Error Handling

**Error Response Format:**
```typescript
interface ErrorResponse {
  error: string;
  details?: any;
  timestamp: number;
  requestId?: string;
}

// Error handling examples
const errorResponses = {
  INVALID_SESSION: {
    error: 'Session not found or access denied',
    status: 404
  },
  INVALID_CURSOR: {
    error: 'Invalid cursor format',
    status: 400
  },
  DATABASE_ERROR: {
    error: 'Database query failed',
    status: 500
  },
  RATE_LIMITED: {
    error: 'Rate limit exceeded',
    status: 429
  }
};
```

### Performance Optimization

**Query Optimization:**
```typescript
// Efficient query building
function buildOptimizedQuery(sessionId: string, limit: number, cursor?: PaginationCursor) {
  // Use composite index for optimal performance
  let query = db
    .collection('aiSessions')
    .doc(sessionId)
    .collection('messages')
    .orderBy('createdAt', 'desc') // Use index
    .limit(limit + 1);
  
  if (cursor) {
    // Use startAfter for cursor-based pagination
    query = query.startAfter(cursor.timestamp, cursor.messageId);
  }
  
  return query;
}

// Add query timeout
const QUERY_TIMEOUT = 5000; // 5 seconds

async function executeWithTimeout<T>(queryPromise: Promise<T>): Promise<T> {
  return Promise.race([
    queryPromise,
    new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error('Query timeout')), QUERY_TIMEOUT)
    )
  ]);
}
```

### Source Tree
```
app/api/ai/copilot/
└── messages/
    └── route.ts           # NEW: Messages pagination API

lib/ai/
├── pagination.ts          # NEW: Pagination logic
├── schemas.ts            # MODIFIED: Add query schemas
└── types.ts              # EXISTING: From Story 13.1

lib/db/
└── aiSessionsRepo.ts     # EXISTING: From Story 13.1
```

### Integration with React Query

**React Query Integration:**
```typescript
// In useMessages hook
function useMessages(sessionId: string) {
  return useInfiniteQuery({
    queryKey: ['messages', sessionId],
    queryFn: async ({ pageParam }) => {
      const response = await fetch(`/api/ai/copilot/messages?sessionId=${sessionId}&cursor=${pageParam}`);
      return response.json();
    },
    getNextPageParam: (lastPage) => {
      return lastPage.pagination.hasMore ? lastPage.pagination.nextCursor : undefined;
    },
    initialPageParam: undefined
  });
}
```

### Testing

**Test Location:** `app/api/ai/copilot/messages/route.test.ts`

**Test Coverage:**
- Valid pagination requests
- Cursor-based navigation
- Error handling scenarios
- Performance with large datasets
- Edge cases (empty results, invalid cursors)

**Example Test:**
```typescript
describe('GET /api/ai/copilot/messages', () => {
  it('returns paginated messages', async () => {
    const response = await fetch('/api/ai/copilot/messages?sessionId=test-session');
    const data = await response.json();
    
    expect(response.status).toBe(200);
    expect(data.items).toBeDefined();
    expect(data.pagination.hasMore).toBeDefined();
    expect(data.meta.sessionId).toBe('test-session');
  });
  
  it('handles invalid cursor', async () => {
    const response = await fetch('/api/ai/copilot/messages?sessionId=test-session&cursor=invalid');
    
    expect(response.status).toBe(400);
    const data = await response.json();
    expect(data.error).toBe('Invalid cursor format');
  });
  
  it('respects limit parameter', async () => {
    const response = await fetch('/api/ai/copilot/messages?sessionId=test-session&limit=5');
    const data = await response.json();
    
    expect(data.items.length).toBeLessThanOrEqual(5);
  });
});
```

### Performance Considerations
- Use Firestore composite indexes
- Implement query timeouts
- Cache frequently accessed data
- Monitor query performance
- Add request rate limiting

### Dependencies
- aiSessionsRepo from Story 13.1
- Zod for validation (existing)
- Next.js API routes (existing)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-13 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent*

### Debug Log References
_To be populated by dev agent*

### Completion Notes List
_To be populated by dev agent*

### File List
_To be populated by dev agent*

## QA Results
_To be populated by QA agent*
