# Story 13.11: Glossary Integration

## Status
Draft

## Story
**As a** FairForm user,
**I want** the AI Copilot to automatically include relevant legal term definitions in responses,
**so that** I can understand legal concepts without needing to look them up separately.

## Acceptance Criteria

1. AI responses automatically include definitions for legal terms mentioned
2. Glossary integration works with existing Epic 7 glossary system
3. Terms are identified based on case context and user questions
4. Definitions are concise and relevant to the user's situation
5. System handles unknown terms gracefully without breaking responses
6. Glossary terms are highlighted in the chat interface
7. Integration works in both demo and production modes
8. Unit tests cover term identification and definition retrieval

## Tasks / Subtasks

- [ ] Task 1: Integrate with Epic 7 glossary system (AC: 2)
  - [ ] Import glossary data from Epic 7 implementation
  - [ ] Create glossary service for term lookup
  - [ ] Add glossary term extraction utilities
  - [ ] Ensure compatibility with existing glossary structure
  - [ ] Add glossary term caching for performance

- [ ] Task 2: Implement term identification logic (AC: 3)
  - [ ] Create term detection algorithms
  - [ ] Identify terms based on case context
  - [ ] Extract terms from user questions
  - [ ] Handle term variations and synonyms
  - [ ] Add term relevance scoring

- [ ] Task 3: Add definition retrieval system (AC: 4, 5)
  - [ ] Create definition lookup functions
  - [ ] Implement definition formatting for AI prompts
  - [ ] Handle missing or incomplete definitions
  - [ ] Add definition length optimization
  - [ ] Implement definition caching

- [ ] Task 4: Integrate with AI prompt system (AC: 1)
  - [ ] Modify prompt templates to include glossary terms
  - [ ] Add glossary context to system prompts
  - [ ] Ensure definitions are included in AI responses
  - [ ] Handle glossary term injection in streaming responses
  - [ ] Add glossary term metadata to messages

- [ ] Task 5: Implement chat UI highlighting (AC: 6)
  - [ ] Add term highlighting in chat messages
  - [ ] Create tooltip system for definitions
  - [ ] Implement click-to-expand functionality
  - [ ] Add visual indicators for glossary terms
  - [ ] Ensure accessibility for highlighted terms

- [ ] Task 6: Add demo mode support (AC: 7)
  - [ ] Create demo glossary data
  - [ ] Ensure glossary works in demo environment
  - [ ] Add demo-specific term examples
  - [ ] Handle demo mode term identification
  - [ ] Test glossary integration in demo

- [ ] Task 7: Add error handling and fallbacks (AC: 5)
  - [ ] Handle glossary service failures
  - [ ] Implement fallback for missing terms
  - [ ] Add graceful degradation when glossary unavailable
  - [ ] Handle term identification errors
  - [ ] Add error logging and monitoring

- [ ] Task 8: Create comprehensive tests (AC: 8)
  - [ ] Test term identification with various inputs
  - [ ] Test definition retrieval and formatting
  - [ ] Test integration with AI prompt system
  - [ ] Test chat UI highlighting functionality
  - [ ] Test error handling scenarios

## Dev Notes

### Architecture Context
[Source: docs/epic-13-unified-architecture-specification.md]

Glossary integration enhances the AI Copilot's **educational value** by automatically providing legal term definitions. This integration leverages the existing Epic 7 glossary system while adding AI-powered term identification and context-aware definition selection.

**Key Design Decisions:**
- Automatic term identification from context
- Integration with existing Epic 7 glossary
- Context-aware definition selection
- Chat UI highlighting for better UX
- Graceful fallback on errors

### Glossary Data Structure

**Glossary Term Interface:**
```typescript
interface GlossaryTerm {
  id: string;
  term: string;
  definition: string;
  category: 'eviction' | 'small_claims' | 'family_law' | 'debt' | 'employment' | 'general';
  jurisdiction?: string;
  relatedTerms: string[];
  examples?: string[];
  complexity: 'simple' | 'intermediate' | 'advanced';
  lastUpdated: number;
}

interface TermMatch {
  term: GlossaryTerm;
  relevance: number;        // 0-1 score
  context: string;         // Where term was found
  position: number;        // Position in text
}
```

### Term Identification

**Term Detection Algorithm:**
```typescript
class GlossaryTermDetector {
  private glossaryTerms: Map<string, GlossaryTerm> = new Map();
  private termVariations: Map<string, string> = new Map();
  
  constructor(glossaryData: GlossaryTerm[]) {
    this.initializeGlossary(glossaryData);
  }
  
  private initializeGlossary(terms: GlossaryTerm[]): void {
    terms.forEach(term => {
      // Store primary term
      this.glossaryTerms.set(term.term.toLowerCase(), term);
      
      // Store variations and synonyms
      term.relatedTerms.forEach(variation => {
        this.glossaryTerms.set(variation.toLowerCase(), term);
        this.termVariations.set(variation.toLowerCase(), term.term);
      });
    });
  }
  
  detectTerms(text: string, context: CaseContext): TermMatch[] {
    const matches: TermMatch[] = [];
    const lowerText = text.toLowerCase();
    
    for (const [termKey, term] of this.glossaryTerms) {
      // Skip if term doesn't match case context
      if (!this.isRelevantToContext(term, context)) {
        continue;
      }
      
      const positions = this.findTermPositions(lowerText, termKey);
      
      positions.forEach(position => {
        const relevance = this.calculateRelevance(term, context, text, position);
        
        matches.push({
          term,
          relevance,
          context: text.substring(Math.max(0, position - 50), position + termKey.length + 50),
          position
        });
      });
    }
    
    // Sort by relevance and return top matches
    return matches
      .sort((a, b) => b.relevance - a.relevance)
      .slice(0, 5); // Limit to top 5 terms
  }
  
  private isRelevantToContext(term: GlossaryTerm, context: CaseContext): boolean {
    if (term.category === 'general') return true;
    if (!context.caseType) return true;
    
    return term.category === context.caseType || 
           term.category === 'general';
  }
  
  private calculateRelevance(term: GlossaryTerm, context: CaseContext, text: string, position: number): number {
    let relevance = 0.5; // Base relevance
    
    // Boost relevance based on case type match
    if (term.category === context.caseType) {
      relevance += 0.3;
    }
    
    // Boost relevance for terms near case-specific keywords
    const caseKeywords = this.getCaseKeywords(context.caseType);
    const surroundingText = text.substring(Math.max(0, position - 100), position + 100);
    
    caseKeywords.forEach(keyword => {
      if (surroundingText.includes(keyword)) {
        relevance += 0.2;
      }
    });
    
    return Math.min(1.0, relevance);
  }
}
```

### Definition Retrieval

**Definition Service:**
```typescript
class GlossaryDefinitionService {
  private cache = new Map<string, string>();
  
  getDefinition(term: GlossaryTerm, context: CaseContext): string {
    const cacheKey = `${term.id}:${context.caseType}`;
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }
    
    const definition = this.formatDefinition(term, context);
    this.cache.set(cacheKey, definition);
    
    return definition;
  }
  
  private formatDefinition(term: GlossaryTerm, context: CaseContext): string {
    let definition = term.definition;
    
    // Shorten definition if too long
    if (definition.length > 200) {
      definition = definition.substring(0, 197) + '...';
    }
    
    // Add context-specific examples if available
    if (context.caseType && term.examples) {
      const relevantExample = term.examples.find(ex => 
        ex.toLowerCase().includes(context.caseType!)
      );
      
      if (relevantExample) {
        definition += ` Example: ${relevantExample}`;
      }
    }
    
    return definition;
  }
  
  getMultipleDefinitions(terms: TermMatch[]): string {
    if (terms.length === 0) return '';
    
    const definitions = terms
      .slice(0, 3) // Limit to top 3 terms
      .map(match => {
        const definition = this.getDefinition(match.term, match.context as CaseContext);
        return `**${match.term.term}**: ${definition}`;
      })
      .join('\n\n');
    
    return `\n\n*Relevant legal terms:*\n${definitions}`;
  }
}
```

### AI Integration

**Prompt Enhancement:**
```typescript
function enhancePromptWithGlossary(
  prompt: string,
  context: CaseContext,
  userMessage: string
): string {
  const detector = new GlossaryTermDetector(glossaryData);
  const definitionService = new GlossaryDefinitionService();
  
  // Detect terms in user message and context
  const userTerms = detector.detectTerms(userMessage, context);
  const contextTerms = detector.detectTerms(JSON.stringify(context), context);
  
  // Combine and deduplicate terms
  const allTerms = [...userTerms, ...contextTerms]
    .filter((match, index, array) => 
      array.findIndex(m => m.term.id === match.term.id) === index
    );
  
  // Get definitions for relevant terms
  const definitions = definitionService.getMultipleDefinitions(allTerms);
  
  // Add glossary context to prompt
  if (definitions) {
    prompt += `\n\nWhen responding, you may include relevant legal term definitions. Here are some terms that might be relevant:\n${definitions}`;
  }
  
  return prompt;
}
```

### Chat UI Highlighting

**Term Highlighting Component:**
```typescript
interface HighlightedMessageProps {
  content: string;
  context: CaseContext;
}

function HighlightedMessage({ content, context }: HighlightedMessageProps) {
  const [detectedTerms, setDetectedTerms] = useState<TermMatch[]>([]);
  
  useEffect(() => {
    const detector = new GlossaryTermDetector(glossaryData);
    const terms = detector.detectTerms(content, context);
    setDetectedTerms(terms);
  }, [content, context]);
  
  const highlightedContent = useMemo(() => {
    let result = content;
    
    // Sort terms by position (reverse order to maintain indices)
    const sortedTerms = detectedTerms.sort((a, b) => b.position - a.position);
    
    sortedTerms.forEach(match => {
      const { term, position } = match;
      const before = result.substring(0, position);
      const after = result.substring(position + term.term.length);
      
      result = before + 
        `<span class="glossary-term" data-term-id="${term.id}">${term.term}</span>` + 
        after;
    });
    
    return result;
  }, [content, detectedTerms]);
  
  return (
    <div className="message-content">
      <div 
        dangerouslySetInnerHTML={{ __html: highlightedContent }}
        onClick={handleTermClick}
      />
      
      {/* Tooltip for term definitions */}
      <GlossaryTooltip terms={detectedTerms} />
    </div>
  );
}

function GlossaryTooltip({ terms }: { terms: TermMatch[] }) {
  const [activeTerm, setActiveTerm] = useState<string | null>(null);
  
  return (
    <div className="glossary-tooltip">
      {terms.map(term => (
        <div
          key={term.term.id}
          className={`tooltip ${activeTerm === term.term.id ? 'active' : ''}`}
        >
          <h4>{term.term.term}</h4>
          <p>{term.term.definition}</p>
          {term.term.examples && (
            <div className="examples">
              <strong>Examples:</strong>
              <ul>
                {term.term.examples.map((example, i) => (
                  <li key={i}>{example}</li>
                ))}
              </ul>
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

### Demo Mode Support

**Demo Glossary Data:**
```typescript
const demoGlossaryData: GlossaryTerm[] = [
  {
    id: 'demo-eviction-1',
    term: 'Eviction Notice',
    definition: 'A legal document that a landlord gives to a tenant to start the eviction process.',
    category: 'eviction',
    jurisdiction: 'California',
    relatedTerms: ['notice', 'termination'],
    examples: ['3-day notice', '30-day notice'],
    complexity: 'simple',
    lastUpdated: Date.now()
  },
  {
    id: 'demo-small-claims-1',
    term: 'Small Claims Court',
    definition: 'A court that handles disputes involving small amounts of money, typically under $10,000.',
    category: 'small_claims',
    jurisdiction: 'California',
    relatedTerms: ['court', 'dispute', 'money'],
    examples: ['rent disputes', 'contract disputes'],
    complexity: 'simple',
    lastUpdated: Date.now()
  }
  // ... more demo terms
];
```

### Error Handling

**Graceful Degradation:**
```typescript
class GlossaryErrorHandler {
  handleGlossaryError(error: Error, context: string): void {
    console.error(`Glossary error in ${context}:`, error);
    
    // Log to monitoring service
    this.logError(error, context);
    
    // Don't break the main flow
    // Glossary is enhancement, not critical functionality
  }
  
  private logError(error: Error, context: string): void {
    // Send to monitoring service (e.g., Sentry, DataDog)
    console.log(`Glossary error logged: ${error.message} in ${context}`);
  }
}

// Usage in glossary service
function safeGetDefinitions(terms: TermMatch[]): string {
  try {
    return definitionService.getMultipleDefinitions(terms);
  } catch (error) {
    glossaryErrorHandler.handleGlossaryError(error, 'definition retrieval');
    return ''; // Return empty string, don't break AI response
  }
}
```

### Source Tree
```
lib/glossary/
├── termDetector.ts        # NEW: Term identification logic
├── definitionService.ts   # NEW: Definition retrieval
├── highlighting.tsx       # NEW: UI highlighting components
└── demoData.ts           # NEW: Demo glossary data

lib/ai/
├── glossaryIntegration.ts # NEW: AI prompt integration
├── contextBuilder.ts      # MODIFIED: Add glossary context
└── promptTemplates.ts     # MODIFIED: Include glossary terms

components/ai-copilot/
├── HighlightedMessage.tsx # NEW: Message with term highlighting
└── GlossaryTooltip.tsx    # NEW: Term definition tooltips
```

### Integration Points

**Context Builder Integration:**
```typescript
// In contextBuilder.ts
function buildContextWithGlossary(
  userId: string,
  caseId?: string,
  sessionId?: string
): Promise<AIPromptContext> {
  const baseContext = buildContext(userId, caseId, sessionId);
  
  // Add glossary context
  if (baseContext.case?.caseType) {
    const relevantTerms = getRelevantGlossaryTerms(baseContext.case.caseType);
    baseContext.glossaryTerms = relevantTerms.map(term => ({
      term: term.term,
      definition: term.definition
    }));
  }
  
  return baseContext;
}
```

### Testing

**Test Location:** `lib/glossary/termDetector.test.ts`

**Test Coverage:**
- Term identification with various text inputs
- Definition retrieval and formatting
- Context relevance scoring
- Chat UI highlighting functionality
- Error handling scenarios
- Demo mode integration

**Example Test:**
```typescript
describe('GlossaryTermDetector', () => {
  it('identifies relevant terms in user message', () => {
    const detector = new GlossaryTermDetector(glossaryData);
    const context = { caseType: 'eviction' };
    const message = 'I received an eviction notice from my landlord';
    
    const matches = detector.detectTerms(message, context);
    
    expect(matches).toHaveLength(1);
    expect(matches[0].term.term).toBe('Eviction Notice');
    expect(matches[0].relevance).toBeGreaterThan(0.7);
  });
  
  it('handles unknown terms gracefully', () => {
    const detector = new GlossaryTermDetector(glossaryData);
    const context = { caseType: 'eviction' };
    const message = 'I have a question about xyz unknown term';
    
    const matches = detector.detectTerms(message, context);
    
    expect(matches).toHaveLength(0);
  });
});
```

### Performance Considerations
- Cache glossary terms and definitions
- Limit term identification to relevant context
- Use efficient string matching algorithms
- Minimize glossary data loading time

### Dependencies
- Epic 7 glossary system (existing)
- contextBuilder from Story 13.3
- Chat UI components from Stories 13.5-13.6

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-13 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent*

### Debug Log References
_To be populated by dev agent*

### Completion Notes List
_To be populated by dev agent*

### File List
_To be populated by dev agent*

## QA Results
_To be populated by QA agent*
