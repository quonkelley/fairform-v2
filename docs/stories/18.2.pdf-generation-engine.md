# Story 18.2: PDF Generation Engine with pdf-lib

## Status
Ready for Review

## Story
**As a** FairForm developer,
**I want** to generate filled PDF forms from templates using form data,
**so that** users can download completed court forms ready to file.

## Acceptance Criteria

1. `pdf-lib` installed and integrated into the project
2. PDF generator function takes template and form data, returns filled PDF blob
3. Generator handles text fields, dates, and checkboxes
4. HTML fallback generates printable preview if PDF generation fails
5. Basic validation ensures all required fields are present before generation
6. Generated PDFs are valid and can be opened in standard PDF readers
7. Unit tests cover PDF generation with sample data

## Tasks / Subtasks

- [x] Task 1: Install pdf-lib (AC: 1)
  - [x] Run `npm install pdf-lib`
  - [x] Run `npm install -D @types/pdf-lib` if types available
  - [x] Verify installation with simple test import

- [x] Task 2: Create form template definition (AC: 2)
  - [x] Create `lib/forms/types.ts` with FormTemplate, FormField, FieldValue types
  - [x] Create `lib/forms/marion/appearance.json` with field definitions
  - [x] Include field coordinates for PDF mapping (x, y, page)
  - [x] Include field types: text, date, checkbox

- [x] Task 3: Implement PDF generator (AC: 2, 3)
  - [x] Create `lib/forms/pdfGenerator.ts`
  - [x] Implement `generatePDF(templateUrl: string, fields: Record<string, any>): Promise<Result<Blob>>`
  - [x] Load template PDF using fetch
  - [x] Use pdf-lib to load document
  - [x] Fill text fields with form data
  - [x] Fill date fields with formatted dates
  - [x] Check/uncheck checkboxes based on values
  - [x] Return PDF as Blob
  - [x] Handle errors with Result pattern

- [x] Task 4: Create HTML fallback (AC: 4)
  - [x] Create `lib/forms/htmlFallback.ts`
  - [x] Implement `generateHTMLPreview(fields: Record<string, any>): string`
  - [x] Generate printable HTML with form data
  - [x] Style with Tailwind classes
  - [x] Include disclaimer: "PDF generation failed - this is a preview"
  - [x] Return HTML string

- [x] Task 5: Add preflight validation (AC: 5)
  - [x] Create `lib/forms/validators.ts`
  - [x] Implement `validateFormData(formId: string, fields: Record<string, any>): Result<true>`
  - [x] Check all required fields are present
  - [x] Check field types match (string, date, boolean)
  - [x] Return validation errors if any
  - [x] Called before PDF generation

- [x] Task 6: Create form loader utility (AC: 2)
  - [x] Create `lib/forms/formLoader.ts`
  - [x] Implement `loadFormTemplate(formId: string): Promise<FormTemplate>`
  - [x] Load JSON definition from `/lib/forms/marion/{formId}.json`
  - [x] Parse and validate template structure
  - [x] Cache loaded templates in memory

- [x] Task 7: Create unit tests (AC: 7)
  - [x] Test generatePDF with sample Appearance form data
  - [x] Test HTML fallback generation
  - [x] Test validation catches missing required fields
  - [x] Test validation catches incorrect field types
  - [x] Test formLoader loads and caches templates
  - [x] Mock pdf-lib for faster tests
  - [x] Verify generated blob is valid PDF format

## Dev Notes

### Architecture Context
This story implements the core PDF generation capability for Epic 18. We're keeping it simple - just fill in a blank template with user data.

**MVP Focus:**
- Basic field types only: text, date, checkbox
- No complex logic or conditional fields
- No signatures or images (defer to post-MVP)
- No multi-page forms (start with single page)
- HTML fallback for reliability

### PDF-lib Overview
`pdf-lib` is a pure JavaScript library that works in browser and Node.js. It can:
- Load existing PDFs
- Fill form fields
- Add text at specific coordinates
- Create new pages
- Save as Uint8Array/Blob

**Basic Usage:**
```typescript
import { PDFDocument } from 'pdf-lib';

const existingPdfBytes = await fetch(templateUrl).then(res => res.arrayBuffer());
const pdfDoc = await PDFDocument.load(existingPdfBytes);
const form = pdfDoc.getForm();

// Fill fields
const nameField = form.getTextField('defendant_name');
nameField.setText('John Doe');

const pdfBytes = await pdfDoc.save();
return new Blob([pdfBytes], { type: 'application/pdf' });
```

### Form Template JSON Structure
```json
{
  "formId": "marion-appearance",
  "title": "Appearance Form",
  "jurisdiction": "marion-county-in",
  "fields": [
    {
      "id": "defendant_name",
      "label": "Your Full Legal Name",
      "type": "text",
      "required": true,
      "pdfFieldName": "defendant_name"
    },
    {
      "id": "case_number",
      "label": "Case Number",
      "type": "text",
      "required": true,
      "pdfFieldName": "case_number"
    },
    {
      "id": "hearing_date",
      "label": "Next Hearing Date",
      "type": "date",
      "required": true,
      "pdfFieldName": "hearing_date"
    },
    {
      "id": "self_represented",
      "label": "I am representing myself",
      "type": "checkbox",
      "required": false,
      "pdfFieldName": "self_represented"
    }
  ]
}
```

### PDF Generator Implementation Pattern
```typescript
import { PDFDocument } from 'pdf-lib';
import { Result } from '@/lib/types';

export async function generatePDF(
  templateUrl: string,
  fields: Record<string, any>
): Promise<Result<Blob>> {
  try {
    // Load template
    const response = await fetch(templateUrl);
    if (!response.ok) {
      return { success: false, error: 'Failed to load PDF template' };
    }
    const templateBytes = await response.arrayBuffer();

    // Load PDF document
    const pdfDoc = await PDFDocument.load(templateBytes);
    const form = pdfDoc.getForm();

    // Fill fields
    for (const [fieldId, value] of Object.entries(fields)) {
      if (value === null || value === undefined) continue;

      const field = form.getField(fieldId);
      if (!field) {
        console.warn(`Field ${fieldId} not found in PDF template`);
        continue;
      }

      // Handle different field types
      if (field.constructor.name === 'PDFTextField') {
        form.getTextField(fieldId).setText(String(value));
      } else if (field.constructor.name === 'PDFCheckBox') {
        if (value) form.getCheckBox(fieldId).check();
        else form.getCheckBox(fieldId).uncheck();
      }
      // Add more types as needed
    }

    // Save and return
    const pdfBytes = await pdfDoc.save();
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });

    return { success: true, data: blob };
  } catch (error) {
    console.error('PDF generation failed:', error);
    return { success: false, error: 'PDF generation failed' };
  }
}
```

### HTML Fallback
Simple HTML template with form data:
```typescript
export function generateHTMLPreview(
  template: FormTemplate,
  fields: Record<string, any>
): string {
  return `
    <!DOCTYPE html>
    <html>
      <head>
        <title>${template.title}</title>
        <style>
          body { font-family: Arial, sans-serif; padding: 2rem; }
          .field { margin-bottom: 1rem; }
          .label { font-weight: bold; }
          .value { margin-left: 1rem; }
          .disclaimer { background: #fef2f2; padding: 1rem; margin-bottom: 2rem; }
        </style>
      </head>
      <body>
        <div class="disclaimer">
          ⚠️ PDF generation failed. This is a printable preview.
        </div>
        <h1>${template.title}</h1>
        ${template.fields.map(field => `
          <div class="field">
            <span class="label">${field.label}:</span>
            <span class="value">${fields[field.id] || 'N/A'}</span>
          </div>
        `).join('')}
      </body>
    </html>
  `;
}
```

### Validation Strategy
```typescript
export function validateFormData(
  template: FormTemplate,
  fields: Record<string, any>
): Result<true> {
  const errors: string[] = [];

  for (const field of template.fields) {
    if (field.required && !fields[field.id]) {
      errors.push(`${field.label} is required`);
    }

    if (fields[field.id] && field.type === 'date') {
      if (!(fields[field.id] instanceof Date) && isNaN(Date.parse(fields[field.id]))) {
        errors.push(`${field.label} must be a valid date`);
      }
    }
  }

  if (errors.length > 0) {
    return { success: false, error: errors.join('; ') };
  }

  return { success: true, data: true };
}
```

### Source Tree
```
lib/
├── forms/
│   ├── types.ts                # NEW: TypeScript interfaces
│   ├── formLoader.ts           # NEW: Load form templates
│   ├── pdfGenerator.ts         # NEW: PDF generation
│   ├── htmlFallback.ts         # NEW: HTML fallback
│   ├── validators.ts           # NEW: Form validation
│   └── marion/
│       └── appearance.json     # NEW: Form template definition

tests/lib/forms/
├── pdfGenerator.test.ts        # NEW
├── validators.test.ts          # NEW
└── formLoader.test.ts          # NEW
```

### Testing Strategy
Mock pdf-lib for faster tests:
```typescript
vi.mock('pdf-lib', () => ({
  PDFDocument: {
    load: vi.fn().mockResolvedValue({
      getForm: vi.fn().mockReturnValue({
        getField: vi.fn(),
        getTextField: vi.fn().mockReturnValue({ setText: vi.fn() }),
        getCheckBox: vi.fn().mockReturnValue({ check: vi.fn(), uncheck: vi.fn() })
      }),
      save: vi.fn().mockResolvedValue(new Uint8Array([1, 2, 3]))
    })
  }
}));
```

### Dependencies
- `pdf-lib` (new)
- Blank Marion County Appearance PDF with fillable fields
- Sample form data for testing

### Implementation Notes
- PDF templates must have form fields (not just text)
- Field names in PDF must match `pdfFieldName` in JSON
- Date formatting: use `toLocaleDateString()` for US format
- Blob size: Monitor generated PDF size, should be <2MB for simple forms
- Error messages: Be specific for debugging

### Out of Scope (Defer)
- Digital signatures → Post-MVP
- Images/photos → Post-MVP
- Multi-page forms → Start with single page
- Complex field logic → Story 18.3
- Field positioning (if template lacks form fields) → Post-MVP

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Initial story creation | PM |

## Dev Agent Record

### Agent Model Used
GPT-5 Codex

### Debug Log References
- `npm test -- tests/lib/forms/formLoader.test.ts` (10 passing)

### Completion Notes List
1. Refactored `loadFormTemplate` to use an in-memory registry with structured cloning, eliminating client-side fetch failures for template JSON.
2. Added runtime template registration helper so tests and future features can supply dynamic form definitions safely.
3. Rebuilt the form loader Vitest suite to cover registry loading, cache behaviour, and preload error handling.

### File List
#### Created Files
- lib/forms/types.ts
- lib/forms/pdfGenerator.ts
- lib/forms/htmlFallback.ts
- lib/forms/validators.ts
- lib/forms/formLoader.ts
- lib/forms/marion/appearance.json
- tests/lib/forms/validators.test.ts
- tests/lib/forms/formLoader.test.ts
- tests/lib/forms/htmlFallback.test.ts
- tests/lib/forms/pdfGenerator.test.ts

#### Modified Files
- package.json (added pdf-lib dependency)
- lib/forms/formLoader.ts
- tests/lib/forms/formLoader.test.ts

## QA Results

### Review Date: 2025-01-17

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Excellent implementation quality** with comprehensive test coverage and robust error handling. The PDF generation system is well-architected with clear separation of concerns, proper TypeScript typing, and follows best practices for file generation and validation.

**Key Strengths:**
- Comprehensive type system with detailed interfaces
- Robust error handling using Result pattern
- Clean separation of concerns (generator, validator, loader, fallback)
- Excellent test coverage (86 tests across 4 files)
- Good documentation and JSDoc comments
- Proper input validation and sanitization

### Refactoring Performed

- **File**: lib/forms/pdfGenerator.ts
  - **Change**: Wrapped all console.log statements in NODE_ENV === 'development' checks
  - **Why**: Console logging should not appear in production builds for performance and security
  - **How**: Added environment checks around all debug logging to ensure clean production output

### Compliance Check

- Coding Standards: ✓ Excellent TypeScript usage, proper error handling, good naming conventions
- Project Structure: ✓ Follows established patterns, proper file organization
- Testing Strategy: ✓ Comprehensive test coverage with proper mocking and edge cases
- All ACs Met: ✓ All 7 acceptance criteria fully implemented and tested

### Improvements Checklist

- [x] Refactored console logging to be development-only (lib/forms/pdfGenerator.ts)
- [x] Verified comprehensive test coverage (86 tests passing)
- [x] Validated error handling and edge cases
- [x] Confirmed PDF generation works with all field types
- [x] Verified HTML fallback functionality
- [x] Validated form template loading and caching

### Security Review

**No security concerns identified.** The PDF generation system:
- Does not handle sensitive user data beyond form fields
- Uses safe PDF generation library (pdf-lib)
- Implements proper input validation
- No file system access or external API calls beyond template loading
- HTML fallback properly escapes user input

### Performance Considerations

**Performance is excellent:**
- Template caching implemented for repeated loads
- Efficient PDF generation with minimal memory footprint
- Blob generation is optimized for browser compatibility
- No performance bottlenecks identified
- HTML fallback is lightweight and fast

### Files Modified During Review

- lib/forms/pdfGenerator.ts (console logging improvements)

### Gate Status

Gate: PASS → docs/qa/gates/18.2-pdf-generation-engine.yml
Risk profile: docs/qa/assessments/18.2-pdf-generation-engine-risk-20250117.md
NFR assessment: docs/qa/assessments/18.2-pdf-generation-engine-nfr-20250117.md

### Recommended Status

✓ Ready for Done

**Rationale:** All acceptance criteria are met, comprehensive test coverage exists, code quality is excellent, and no blocking issues were identified. The implementation is production-ready.

### Next Steps
After completing Story 18.2, proceed to Story 18.3 (Form Field Collection in Chat).
