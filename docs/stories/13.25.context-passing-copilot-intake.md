# Story 13.25: Intelligent Context Passing Between Copilot & Intake

## Status
Draft

## Story
**As a** FairForm user,
**I want** my conversation details to follow me between the AI Copilot and the form interface,
**so that** I never have to re-enter information and can switch between methods seamlessly.

## Acceptance Criteria

1. When user navigates to /intake after Copilot conversation, form is prefilled with conversation details
2. Prefilled data includes: case type, location (jurisdiction), and problem description (from conversation summary)
3. User sees informational message: "We've filled in details from your conversation"
4. User can edit any prefilled fields before submitting
5. Form submission creates case with both conversation context and form data
6. When user opens Copilot after starting form, Copilot references draft form data
7. Copilot can answer questions about information already entered in form
8. Session ID is maintained across both interfaces (Copilot ↔ Form)
9. Context passing works in both directions (bidirectional)
10. If no Copilot session exists, form works normally (backward compatible)
11. Form submission clears the session context (case is created, context no longer needed)
12. Context is stored client-side (sessionStorage) for privacy and performance

## Tasks / Subtasks

- [ ] Task 1: Create context storage service (AC: 12)
  - [ ] Create `lib/ai/contextStorage.ts` module
  - [ ] Implement `saveIntakeContext()` function
  - [ ] Implement `loadIntakeContext()` function
  - [ ] Implement `clearIntakeContext()` function
  - [ ] Use sessionStorage (clears on tab close)
  - [ ] Define TypeScript interface for IntakeContext
  - [ ] Add expiration timestamp (context valid for 1 hour)
  - [ ] Add unit tests for storage operations

- [ ] Task 2: Export context from Copilot conversation (AC: 1, 8)
  - [ ] Modify demo endpoint to save context to sessionStorage
  - [ ] Save after each message exchange
  - [ ] Include: sessionId, caseType, details, conversation summary
  - [ ] Include timestamp for expiration
  - [ ] Only save if user has provided details
  - [ ] Don't overwrite with empty values

- [ ] Task 3: Implement form prefill logic (AC: 1, 2, 3, 4)
  - [ ] Modify /intake page to load context on mount
  - [ ] Map conversation details to form fields
  - [ ] Set form default values from context
  - [ ] Show informational banner when prefilled
  - [ ] Allow user to dismiss banner
  - [ ] Allow editing all prefilled fields
  - [ ] Validate prefilled data same as manual entry

- [ ] Task 4: Create mapping functions (AC: 2)
  - [ ] Create `mapConversationToFormData()` function
  - [ ] Map caseType to form case type field
  - [ ] Map location/jurisdiction to jurisdiction field
  - [ ] Generate problem description from conversation summary
  - [ ] Handle missing or partial data gracefully
  - [ ] Add unit tests for mapping

- [ ] Task 5: Implement form → Copilot context (AC: 6, 7)
  - [ ] Save form draft state to sessionStorage as user types
  - [ ] Debounce saves (save after 1 second of no typing)
  - [ ] Include form values in context
  - [ ] Modify Copilot to load form context
  - [ ] Allow Copilot to reference form values in responses
  - [ ] Example: "I see you've already entered [location] in the form"

- [ ] Task 6: Enhance Copilot with form awareness (AC: 7)
  - [ ] Load form context when Copilot opens
  - [ ] Include form context in conversation state
  - [ ] Generate contextual responses referencing form data
  - [ ] Suggest returning to form if partially complete
  - [ ] Example: "You've already entered your case type in the form. Would you like to continue there or discuss it here?"

- [ ] Task 7: Handle context lifecycle (AC: 11, 12)
  - [ ] Clear context after successful case creation
  - [ ] Clear context on form submission
  - [ ] Check expiration on context load
  - [ ] Remove expired context automatically
  - [ ] Handle page refresh gracefully
  - [ ] Handle multiple tabs (last write wins)

- [ ] Task 8: Add informational UI elements (AC: 3)
  - [ ] Create InfoBanner component for prefill notification
  - [ ] Show at top of form when prefilled
  - [ ] Include message: "We've filled in details from your conversation with the AI Assistant"
  - [ ] Allow dismissal (close button)
  - [ ] Style with info colors (blue/neutral)
  - [ ] Make mobile responsive

- [ ] Task 9: Ensure backward compatibility (AC: 10)
  - [ ] Form works normally when no context exists
  - [ ] No errors if sessionStorage is unavailable
  - [ ] Graceful degradation for old browsers
  - [ ] Test with empty context
  - [ ] Test with partial context
  - [ ] Test with invalid context

- [ ] Task 10: Add comprehensive testing (AC: All)
  - [ ] Test Copilot → Form context passing
  - [ ] Test Form → Copilot context passing
  - [ ] Test context expiration
  - [ ] Test context clearing after submission
  - [ ] Test with missing context
  - [ ] Test with partial context
  - [ ] Test concurrent editing (multiple tabs)
  - [ ] Test mobile experience
  - [ ] Integration test full bidirectional flow

## Dev Notes

### Architecture Context
[Source: docs/HANDOFF-NEXT-SESSION.md]

This story implements the **final piece of seamless case creation UX** - ensuring users never lose their progress when switching between the conversational Copilot and the structured form. Whether they start in Copilot and want to finish in the form, or vice versa, their information follows them.

**Key Design Principles:**
- Never make users re-enter information
- Respect user choice of interface
- Privacy-first (client-side storage only)
- Backward compatible (works without context)
- Graceful degradation
- Clear communication to user

### Context Storage Service

**File Location:** `lib/ai/contextStorage.ts`

```typescript
export interface IntakeContext {
  sessionId?: string;
  timestamp: number;
  source: 'copilot' | 'form';
  caseType?: string;
  jurisdiction?: string;
  problemDescription?: string;
  details?: {
    location?: string;
    noticeType?: string;
    dateReceived?: string;
    [key: string]: string | undefined;
  };
  formData?: {
    title?: string;
    caseType?: string;
    jurisdiction?: string;
    notes?: string;
  };
}

const STORAGE_KEY = 'fairform_intake_context';
const EXPIRATION_MS = 60 * 60 * 1000; // 1 hour

/**
 * Save intake context to sessionStorage
 */
export function saveIntakeContext(context: Partial<IntakeContext>): void {
  try {
    const existing = loadIntakeContext();
    const updated: IntakeContext = {
      ...existing,
      ...context,
      timestamp: Date.now()
    };
    
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
    console.log('[Context] Saved:', updated.source);
  } catch (error) {
    console.error('[Context] Failed to save:', error);
    // Fail silently - not critical
  }
}

/**
 * Load intake context from sessionStorage
 */
export function loadIntakeContext(): IntakeContext | null {
  try {
    const stored = sessionStorage.getItem(STORAGE_KEY);
    if (!stored) return null;
    
    const context: IntakeContext = JSON.parse(stored);
    
    // Check expiration
    const age = Date.now() - context.timestamp;
    if (age > EXPIRATION_MS) {
      console.log('[Context] Expired, clearing');
      clearIntakeContext();
      return null;
    }
    
    console.log('[Context] Loaded:', context.source);
    return context;
  } catch (error) {
    console.error('[Context] Failed to load:', error);
    return null;
  }
}

/**
 * Clear intake context from sessionStorage
 */
export function clearIntakeContext(): void {
  try {
    sessionStorage.removeItem(STORAGE_KEY);
    console.log('[Context] Cleared');
  } catch (error) {
    console.error('[Context] Failed to clear:', error);
  }
}

/**
 * Check if context exists
 */
export function hasIntakeContext(): boolean {
  return loadIntakeContext() !== null;
}

/**
 * Map conversation state to intake context
 */
export function conversationToContext(state: {
  sessionId?: string;
  caseType?: string;
  details?: Record<string, string | undefined>;
  context?: string[];
}): IntakeContext {
  return {
    timestamp: Date.now(),
    source: 'copilot',
    sessionId: state.sessionId,
    caseType: state.caseType,
    jurisdiction: state.details?.location,
    problemDescription: generateProblemDescription(state),
    details: state.details
  };
}

/**
 * Generate problem description from conversation
 */
function generateProblemDescription(state: {
  caseType?: string;
  details?: Record<string, string | undefined>;
  context?: string[];
}): string {
  let description = '';
  
  // Start with case type context
  if (state.caseType === 'eviction') {
    description = 'User is facing an eviction. ';
    if (state.details?.noticeType) {
      description += `Received ${state.details.noticeType.replace(/-/g, ' ')} notice. `;
    }
  } else if (state.caseType === 'small_claims') {
    description = 'User has a small claims matter. ';
  }
  
  // Add first user message if available
  if (state.context && state.context.length > 0) {
    description += `Original concern: "${state.context[0]}"`;
  }
  
  return description;
}

/**
 * Map form data to intake context
 */
export function formDataToContext(formData: {
  title?: string;
  caseType?: string;
  jurisdiction?: string;
  notes?: string;
}): IntakeContext {
  return {
    timestamp: Date.now(),
    source: 'form',
    caseType: formData.caseType,
    jurisdiction: formData.jurisdiction,
    problemDescription: formData.notes,
    formData
  };
}
```

### Copilot Context Export

**Modifications to `app/api/ai/copilot/demo/route.ts`:**

```typescript
import { conversationToContext, saveIntakeContext } from '@/lib/ai/contextStorage';

function generateDemoResponse(userMessage: string, sessionId: string, history: string[]): string {
  // ... existing code ...
  
  // Save context to sessionStorage after each exchange
  // (This happens on client-side in ChatPanel)
  
  // Include context export in response metadata
  const contextData = conversationToContext({
    sessionId,
    caseType: state.caseType,
    details: state.details,
    context: state.context
  });
  
  // Return metadata for client to save
  return {
    reply: responseText,
    meta: {
      saveContext: contextData
    }
  };
}
```

**Client-side in ChatPanel:**

```typescript
// In ChatPanel.tsx
import { saveIntakeContext } from '@/lib/ai/contextStorage';

// After receiving message from AI
useEffect(() => {
  if (lastMessage?.meta?.saveContext) {
    saveIntakeContext(lastMessage.meta.saveContext);
  }
}, [lastMessage]);
```

### Form Prefill Implementation

**Modifications to `app/intake/page.tsx`:**

```typescript
'use client';

import { useState, useEffect } from 'react';
import { loadIntakeContext, clearIntakeContext, hasIntakeContext } from '@/lib/ai/contextStorage';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { X, Info } from 'lucide-react';

export default function IntakePage() {
  const [showPrefillNotice, setShowPrefillNotice] = useState(false);
  const [prefillData, setPrefillData] = useState<any>(null);

  // Load context on mount
  useEffect(() => {
    const context = loadIntakeContext();
    if (context && context.source === 'copilot') {
      setPrefillData({
        caseType: context.caseType,
        jurisdiction: context.jurisdiction,
        notes: context.problemDescription,
        // Map other fields as needed
      });
      setShowPrefillNotice(true);
      console.log('[Intake] Prefilled from Copilot context');
    }
  }, []);

  return (
    <div className="container mx-auto max-w-4xl p-4 space-y-6">
      {/* ... existing header and CTA ... */}

      {/* Prefill Notice */}
      {showPrefillNotice && (
        <Alert className="border-blue-500/50 bg-blue-50 dark:bg-blue-950/20">
          <Info className="h-4 w-4 text-blue-600" />
          <AlertDescription className="flex items-start justify-between gap-4">
            <div className="text-sm">
              <strong>We've filled in details from your conversation</strong> with the AI Assistant.
              You can edit any of these details before submitting.
            </div>
            <button
              onClick={() => setShowPrefillNotice(false)}
              className="text-blue-600 hover:text-blue-800"
              aria-label="Dismiss"
            >
              <X className="h-4 w-4" />
            </button>
          </AlertDescription>
        </Alert>
      )}

      {/* Form with prefilled data */}
      <AIIntakeForm defaultValues={prefillData} />
    </div>
  );
}
```

**Modifications to AIIntakeForm component:**

```typescript
export function AIIntakeForm({ defaultValues }: { defaultValues?: any }) {
  const [formData, setFormData] = useState({
    caseType: defaultValues?.caseType || '',
    jurisdiction: defaultValues?.jurisdiction || '',
    notes: defaultValues?.notes || '',
    ...
  });

  // Save draft to context as user types (debounced)
  useEffect(() => {
    const timer = setTimeout(() => {
      if (formData.caseType || formData.jurisdiction || formData.notes) {
        saveIntakeContext(formDataToContext(formData));
      }
    }, 1000);

    return () => clearTimeout(timer);
  }, [formData]);

  // Clear context on successful submission
  async function handleSubmit(e: FormEvent) {
    e.preventDefault();
    
    try {
      await submitCase(formData);
      clearIntakeContext(); // Clear after successful creation
      router.push(`/cases/${caseId}`);
    } catch (error) {
      // Handle error
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields with prefilled values */}
    </form>
  );
}
```

### Copilot Form Awareness

**Modifications to Copilot to reference form data:**

```typescript
// In demo endpoint or chat endpoint
import { loadIntakeContext } from '@/lib/ai/contextStorage';

function generateDemoResponse(userMessage: string, sessionId: string, history: string[]): string {
  // Load any form context
  const context = loadIntakeContext();
  
  if (context && context.source === 'form' && context.formData) {
    // User has started filling form
    const formData = context.formData;
    
    // Reference form data in responses
    if (formData.caseType && !state.caseType) {
      return `I see you've already selected "${formData.caseType}" as your case type in the form. ` +
        `Would you like to continue filling out the form, or would you prefer to discuss your situation here first?`;
    }
    
    if (formData.jurisdiction) {
      state.details.location = formData.jurisdiction;
    }
  }
  
  // ... rest of existing logic ...
}
```

### Bidirectional Flow Example

**Scenario 1: Copilot → Form**
```
1. User chats with Copilot about eviction
2. Copilot gathers: caseType=eviction, location=Indianapolis, noticeType=30-day
3. Context saved to sessionStorage automatically
4. User clicks "Try Quick Form" link
5. Form loads, detects context
6. Form prefills: Case Type=Eviction, Jurisdiction=Indianapolis, IN, Notes="User received 30-day eviction notice..."
7. User sees info banner: "We've filled in details from your conversation"
8. User reviews, edits if needed, submits
9. Case created with all context
10. Context cleared
```

**Scenario 2: Form → Copilot**
```
1. User starts filling form
2. Enters: Case Type=Small Claims, Jurisdiction=Fort Wayne
3. Form saves draft to sessionStorage (debounced)
4. User has questions, opens Copilot
5. Copilot loads form context
6. User: "What do I need for small claims?"
7. Copilot: "I see you've already selected Small Claims in Fort Wayne. For small claims in Fort Wayne, you'll need..."
8. User asks more questions, gets guidance
9. User returns to form to complete
10. Submits form
11. Case created, context cleared
```

### Source Tree

```
lib/ai/
├── contextStorage.ts          # NEW: Context storage and mapping
├── contextStorage.test.ts     # NEW: Tests
├── caseCreation.ts           # EXISTING: From Story 13.23
└── intentDetection.ts        # EXISTING: From Story 13.21

app/intake/
└── page.tsx                  # MODIFIED: Load and display prefilled data

components/intake/
└── ai-intake-form.tsx        # MODIFIED: Accept defaultValues, save drafts

components/ai-copilot/
├── ChatPanel.tsx             # MODIFIED: Save context from responses
└── demo/
    └── route.ts              # MODIFIED: Export context, load form context
```

### Testing

**Test Location:** `lib/ai/contextStorage.test.ts`

**Test Coverage:**
```typescript
describe('contextStorage', () => {
  beforeEach(() => {
    sessionStorage.clear();
  });

  describe('saveIntakeContext', () => {
    it('saves context to sessionStorage', () => {
      const context = {
        source: 'copilot' as const,
        caseType: 'eviction',
        jurisdiction: 'Indianapolis'
      };
      
      saveIntakeContext(context);
      
      const stored = sessionStorage.getItem('fairform_intake_context');
      expect(stored).toBeTruthy();
      
      const parsed = JSON.parse(stored!);
      expect(parsed.caseType).toBe('eviction');
      expect(parsed.timestamp).toBeTruthy();
    });
    
    it('merges with existing context', () => {
      saveIntakeContext({ caseType: 'eviction' });
      saveIntakeContext({ jurisdiction: 'Indianapolis' });
      
      const context = loadIntakeContext();
      expect(context?.caseType).toBe('eviction');
      expect(context?.jurisdiction).toBe('Indianapolis');
    });
  });
  
  describe('loadIntakeContext', () => {
    it('loads context from sessionStorage', () => {
      const context = {
        timestamp: Date.now(),
        source: 'copilot' as const,
        caseType: 'eviction'
      };
      
      sessionStorage.setItem('fairform_intake_context', JSON.stringify(context));
      
      const loaded = loadIntakeContext();
      expect(loaded?.caseType).toBe('eviction');
    });
    
    it('returns null for expired context', () => {
      const context = {
        timestamp: Date.now() - (2 * 60 * 60 * 1000), // 2 hours ago
        source: 'copilot' as const,
        caseType: 'eviction'
      };
      
      sessionStorage.setItem('fairform_intake_context', JSON.stringify(context));
      
      const loaded = loadIntakeContext();
      expect(loaded).toBeNull();
    });
    
    it('handles missing context gracefully', () => {
      const loaded = loadIntakeContext();
      expect(loaded).toBeNull();
    });
  });
  
  describe('clearIntakeContext', () => {
    it('removes context from sessionStorage', () => {
      saveIntakeContext({ caseType: 'eviction' });
      expect(hasIntakeContext()).toBe(true);
      
      clearIntakeContext();
      expect(hasIntakeContext()).toBe(false);
    });
  });
  
  describe('conversationToContext', () => {
    it('maps conversation state to context', () => {
      const state = {
        sessionId: 'session-123',
        caseType: 'eviction',
        details: {
          location: 'Indianapolis, IN',
          noticeType: '30-day'
        },
        context: ['I received an eviction notice']
      };
      
      const context = conversationToContext(state);
      
      expect(context.source).toBe('copilot');
      expect(context.caseType).toBe('eviction');
      expect(context.jurisdiction).toBe('Indianapolis, IN');
      expect(context.problemDescription).toContain('eviction notice');
    });
  });
  
  describe('formDataToContext', () => {
    it('maps form data to context', () => {
      const formData = {
        title: 'My Case',
        caseType: 'eviction',
        jurisdiction: 'Marion County, IN',
        notes: 'Received notice today'
      };
      
      const context = formDataToContext(formData);
      
      expect(context.source).toBe('form');
      expect(context.caseType).toBe('eviction');
      expect(context.jurisdiction).toBe('Marion County, IN');
    });
  });
});

describe('Intake Page Integration', () => {
  it('prefills form from Copilot context', () => {
    // Save Copilot context
    saveIntakeContext({
      source: 'copilot',
      caseType: 'eviction',
      jurisdiction: 'Indianapolis, IN',
      problemDescription: 'User received 30-day eviction notice'
    });
    
    render(<IntakePage />);
    
    // Should show prefill notice
    expect(screen.getByText(/filled in details from your conversation/i)).toBeInTheDocument();
    
    // Form should be prefilled
    expect(screen.getByLabelText(/case type/i)).toHaveValue('eviction');
    expect(screen.getByLabelText(/jurisdiction/i)).toHaveValue('Indianapolis, IN');
  });
  
  it('works normally without context', () => {
    render(<IntakePage />);
    
    // Should not show prefill notice
    expect(screen.queryByText(/filled in details/i)).not.toBeInTheDocument();
    
    // Form should be empty
    expect(screen.getByLabelText(/case type/i)).toHaveValue('');
  });
});
```

### Dependencies
- Story 13.23 (Connect to API) - case creation logic
- Story 13.24 (Redesign Page) - form page structure
- sessionStorage API (browser)
- AIIntakeForm component

### Performance Considerations
- sessionStorage is synchronous but fast
- Debounce form saves (1 second delay)
- Context size is small (<1KB typically)
- No network calls for context passing
- Expiration prevents stale data accumulation

### Privacy Considerations
- sessionStorage (not localStorage) - clears on tab close
- No server-side storage of conversation context
- Context expires after 1 hour
- No PII in context (just structured data)
- User can always clear manually

### Error Handling
- Graceful fallback if sessionStorage unavailable
- Silent failure for non-critical operations
- Form always works without context
- Copilot always works without form context
- Clear error messages if context load fails

### Browser Compatibility
- sessionStorage: All modern browsers (IE8+)
- Polyfill not needed for target browsers
- Feature detection for sessionStorage
- Graceful degradation for old browsers

### Next Steps
This story completes the Case Creation Integration flow:
- Users can start in either interface
- Context follows them seamlessly
- No information is lost or re-entered
- Future: Extend to case detail page context

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | Initial story creation for intelligent context passing | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent during implementation_

### Debug Log References
_To be populated by dev agent during implementation_

### Completion Notes List
_To be populated by dev agent during implementation_

### File List
_To be populated by dev agent during implementation_

## QA Results
_To be populated by QA agent after implementation review_

