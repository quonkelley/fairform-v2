# Story 13.17: PII Redaction

## Status
Draft

## Story
**As a** FairForm privacy officer,
**I want** automatic PII (Personally Identifiable Information) redaction in AI context and logs,
**so that** sensitive user data is protected from exposure in AI prompts, logs, and external API calls.

## Acceptance Criteria

1. PII patterns are detected and redacted before sending to OpenAI API
2. Redaction covers common PII types (SSN, phone, email, addresses, names)
3. Redacted content is replaced with placeholder tokens (e.g., [EMAIL], [PHONE])
4. Original content is preserved in secure Firestore storage (not sent to AI)
5. Redaction is optional via user opt-in for "improved results"
6. Redaction rules are configurable and extensible
7. Audit logs show redaction events for compliance
8. Unit tests cover all PII pattern detection and redaction

## Tasks / Subtasks

- [ ] Task 1: Create PII detection patterns (AC: 2)
  - [ ] Define regex patterns for SSN, phone, email
  - [ ] Add patterns for addresses and zip codes
  - [ ] Add patterns for credit cards
  - [ ] Add patterns for dates of birth
  - [ ] Support configurable pattern library

- [ ] Task 2: Implement redaction service (AC: 1, 3, 4)
  - [ ] Create `lib/ai/piiRedaction.ts`
  - [ ] Implement pattern matching logic
  - [ ] Add placeholder token replacement
  - [ ] Preserve original content mapping
  - [ ] Support bi-directional mapping (redact/restore)

- [ ] Task 3: Integrate with context builder (AC: 1, 5)
  - [ ] Add redaction to context builder
  - [ ] Apply redaction before OpenAI calls
  - [ ] Support opt-in bypass for improved results
  - [ ] Handle field-level redaction (allowlist)
  - [ ] Maintain context fingerprint after redaction

- [ ] Task 4: Create opt-in mechanism (AC: 5)
  - [ ] Add user preference for PII sharing
  - [ ] Create "Improve Results" consent flow
  - [ ] Store preference in user settings
  - [ ] Apply preference to all sessions
  - [ ] Add UI toggle in settings

- [ ] Task 5: Implement audit logging (AC: 7)
  - [ ] Log all redaction events
  - [ ] Track what was redacted (without storing PII)
  - [ ] Record user opt-in/opt-out events
  - [ ] Support compliance reporting
  - [ ] Add monitoring for redaction rates

- [ ] Task 6: Add configuration management (AC: 6)
  - [ ] Create redaction configuration file
  - [ ] Support custom patterns
  - [ ] Allow pattern overrides per jurisdiction
  - [ ] Add pattern testing utilities
  - [ ] Document pattern syntax

- [ ] Task 7: Handle edge cases (AC: 1, 4)
  - [ ] Handle multi-byte characters
  - [ ] Preserve whitespace and formatting
  - [ ] Handle overlapping patterns
  - [ ] Support partial redaction
  - [ ] Handle false positives gracefully

- [ ] Task 8: Create comprehensive tests (AC: 8)
  - [ ] Test all PII pattern detection
  - [ ] Test redaction and restoration
  - [ ] Test opt-in/opt-out flows
  - [ ] Test edge cases and false positives
  - [ ] Test performance with large content

## Dev Notes

### Architecture Context
[Source: docs/epic-13-unified-architecture-specification.md, Section 4.2]

PII redaction is **critical for privacy compliance** - it prevents sensitive data from leaving the FairForm infrastructure. The system uses **field allowlisting** by default, with optional raw text processing for users who opt in for "improved results."

**Key Design Decisions:**
- Allowlist approach: Only specific fields sent to AI by default
- Regex-based pattern matching for PII detection
- Placeholder tokens preserve context length
- User opt-in required for raw text processing
- Comprehensive audit logging

### PII Detection Patterns

**Pattern Library:**
```typescript
// lib/ai/piiPatterns.ts

export interface PIIPattern {
  name: string;
  pattern: RegExp;
  placeholder: string;
  description: string;
  confidence: 'high' | 'medium' | 'low';
}

export const PII_PATTERNS: PIIPattern[] = [
  // Social Security Numbers
  {
    name: 'ssn',
    pattern: /\b\d{3}-\d{2}-\d{4}\b/g,
    placeholder: '[SSN]',
    description: 'Social Security Number (XXX-XX-XXXX)',
    confidence: 'high'
  },
  {
    name: 'ssn_no_dash',
    pattern: /\b\d{9}\b/g,
    placeholder: '[SSN]',
    description: 'Social Security Number (XXXXXXXXX)',
    confidence: 'medium'
  },

  // Phone Numbers
  {
    name: 'phone_us',
    pattern: /\b(\+1[-.\s]?)?(\(?\d{3}\)?[-.\s]?)?\d{3}[-.\s]?\d{4}\b/g,
    placeholder: '[PHONE]',
    description: 'US Phone Number',
    confidence: 'high'
  },

  // Email Addresses
  {
    name: 'email',
    pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
    placeholder: '[EMAIL]',
    description: 'Email Address',
    confidence: 'high'
  },

  // Credit Card Numbers
  {
    name: 'credit_card',
    pattern: /\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g,
    placeholder: '[CREDIT_CARD]',
    description: 'Credit Card Number',
    confidence: 'high'
  },

  // ZIP Codes
  {
    name: 'zip_code',
    pattern: /\b\d{5}(-\d{4})?\b/g,
    placeholder: '[ZIP]',
    description: 'ZIP Code',
    confidence: 'medium'
  },

  // Street Addresses (simplified)
  {
    name: 'street_address',
    pattern: /\b\d{1,5}\s+([A-Z][a-z]+\s+){1,3}(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct)\b/gi,
    placeholder: '[ADDRESS]',
    description: 'Street Address',
    confidence: 'medium'
  },

  // Dates of Birth
  {
    name: 'dob',
    pattern: /\b(0?[1-9]|1[0-2])[\/\-](0?[1-9]|[12]\d|3[01])[\/\-](19|20)\d{2}\b/g,
    placeholder: '[DOB]',
    description: 'Date of Birth (MM/DD/YYYY)',
    confidence: 'medium'
  },

  // IP Addresses
  {
    name: 'ip_address',
    pattern: /\b(?:\d{1,3}\.){3}\d{1,3}\b/g,
    placeholder: '[IP]',
    description: 'IP Address',
    confidence: 'low'
  }
];

export const PII_PATTERN_MAP = new Map(
  PII_PATTERNS.map(p => [p.name, p])
);
```

### Redaction Service Implementation

**Core Service:**
```typescript
// lib/ai/piiRedaction.ts

import { PII_PATTERNS, PIIPattern } from './piiPatterns';

export interface RedactionResult {
  redactedContent: string;
  originalContent: string;
  redactions: RedactionEntry[];
  hasRedactions: boolean;
}

export interface RedactionEntry {
  pattern: string;
  placeholder: string;
  position: number;
  length: number;
  confidence: 'high' | 'medium' | 'low';
}

export interface RedactionOptions {
  patterns?: PIIPattern[];
  minConfidence?: 'high' | 'medium' | 'low';
  preserveLength?: boolean;
}

export class PIIRedactionService {
  private patterns: PIIPattern[];
  private confidenceLevels = { high: 3, medium: 2, low: 1 };

  constructor(patterns?: PIIPattern[]) {
    this.patterns = patterns || PII_PATTERNS;
  }

  /**
   * Redact PII from content
   */
  redact(
    content: string,
    options: RedactionOptions = {}
  ): RedactionResult {
    const minConfidence = options.minConfidence || 'low';
    const minLevel = this.confidenceLevels[minConfidence];

    let redactedContent = content;
    const redactions: RedactionEntry[] = [];

    // Apply each pattern
    for (const pattern of this.patterns) {
      const patternLevel = this.confidenceLevels[pattern.confidence];

      // Skip if below minimum confidence
      if (patternLevel < minLevel) {
        continue;
      }

      // Find all matches
      const matches = Array.from(redactedContent.matchAll(pattern.pattern));

      for (const match of matches) {
        if (match.index !== undefined) {
          const originalText = match[0];
          const placeholder = options.preserveLength
            ? this.createLengthPreservingPlaceholder(pattern.placeholder, originalText.length)
            : pattern.placeholder;

          redactions.push({
            pattern: pattern.name,
            placeholder: pattern.placeholder,
            position: match.index,
            length: originalText.length,
            confidence: pattern.confidence
          });

          // Replace with placeholder
          redactedContent = redactedContent.replace(originalText, placeholder);
        }
      }
    }

    return {
      redactedContent,
      originalContent: content,
      redactions,
      hasRedactions: redactions.length > 0
    };
  }

  /**
   * Create length-preserving placeholder
   */
  private createLengthPreservingPlaceholder(
    baseToken: string,
    targetLength: number
  ): string {
    if (baseToken.length >= targetLength) {
      return baseToken.substring(0, targetLength);
    }

    // Pad with asterisks to match length
    const padding = '*'.repeat(targetLength - baseToken.length);
    return baseToken + padding;
  }

  /**
   * Detect PII without redaction (for analysis)
   */
  detectPII(content: string): {
    hasPII: boolean;
    patterns: string[];
    confidence: 'high' | 'medium' | 'low';
  } {
    const detectedPatterns = new Set<string>();
    let highestConfidence: 'low' | 'medium' | 'high' = 'low';

    for (const pattern of this.patterns) {
      if (pattern.pattern.test(content)) {
        detectedPatterns.add(pattern.name);

        // Track highest confidence level
        if (
          this.confidenceLevels[pattern.confidence] >
          this.confidenceLevels[highestConfidence]
        ) {
          highestConfidence = pattern.confidence;
        }
      }
    }

    return {
      hasPII: detectedPatterns.size > 0,
      patterns: Array.from(detectedPatterns),
      confidence: highestConfidence
    };
  }

  /**
   * Add custom pattern
   */
  addPattern(pattern: PIIPattern): void {
    this.patterns.push(pattern);
  }

  /**
   * Remove pattern by name
   */
  removePattern(name: string): void {
    this.patterns = this.patterns.filter(p => p.name !== name);
  }
}
```

### Integration with Context Builder

**Enhanced Context Builder:**
```typescript
// lib/ai/contextBuilder.ts (additions)

import { PIIRedactionService } from './piiRedaction';

export async function buildPromptContext(
  userId: string,
  caseId?: string,
  userPrefs?: ContextSnapshot['userPrefs']
): Promise<AIPromptContext> {
  const redactionService = new PIIRedactionService();

  // Build base context with allowlisted fields only
  const context: AIPromptContext = {
    user: {
      id: userId,
      timeZone: userPrefs?.timeZone
    },
    summary: '',
    fingerprint: ''
  };

  if (caseId) {
    const caseData = await getCase(caseId);
    const steps = await listStepsByCase(caseId);

    if (caseData) {
      // Only include allowlisted fields by default
      context.case = {
        id: caseData.id,
        caseType: caseData.caseType,
        jurisdiction: caseData.jurisdiction,
        currentStepOrder: caseData.currentStep,
        progressPct: caseData.progressPct
      };

      // Build summary from structured data only
      const incompleteSteps = steps.filter(s => !s.isComplete).slice(0, 3);
      context.summary = `User has a ${caseData.caseType} case in ${caseData.jurisdiction}. ` +
        `Progress: ${caseData.progressPct}%. ` +
        `Next steps: ${incompleteSteps.map(s => s.title).join(', ')}.`;

      // Optional: Include narrative fields if user opted in
      if (userPrefs?.allowPIISharing && caseData.narrative) {
        const redactionResult = redactionService.redact(caseData.narrative, {
          minConfidence: 'medium'
        });

        // Log redaction event
        if (redactionResult.hasRedactions) {
          await logRedactionEvent({
            userId,
            caseId,
            redactionCount: redactionResult.redactions.length,
            patterns: redactionResult.redactions.map(r => r.pattern)
          });
        }

        context.summary += `\n\nCase Details: ${redactionResult.redactedContent}`;
      }
    }
  }

  // Generate fingerprint
  const fingerprintData = JSON.stringify({
    caseType: context.case?.caseType,
    jurisdiction: context.case?.jurisdiction,
    currentStep: context.case?.currentStepOrder,
    userPrefs
  });

  context.fingerprint = crypto
    .createHash('sha256')
    .update(fingerprintData)
    .digest('hex');

  return context;
}

async function logRedactionEvent(event: {
  userId: string;
  caseId: string;
  redactionCount: number;
  patterns: string[];
}): Promise<void> {
  const db = getAdminFirestore();

  await db.collection('redactionEvents').add({
    ...event,
    timestamp: Date.now()
  });

  console.log('[REDACTION]', {
    userId: event.userId,
    caseId: event.caseId,
    redactionCount: event.redactionCount,
    patterns: event.patterns
  });
}
```

### User Opt-In System

**User Settings:**
```typescript
// lib/db/userSettings.ts

export interface UserAISettings {
  allowPIISharing: boolean;
  aiParticipation: boolean;
  tone: 'formal' | 'friendly' | 'helpful';
  complexity: 'simple' | 'detailed';
}

export async function updateAISettings(
  userId: string,
  settings: Partial<UserAISettings>
): Promise<void> {
  const db = getAdminFirestore();

  await db.collection('users').doc(userId).update({
    'settings.ai': settings,
    updatedAt: Date.now()
  });

  // Log opt-in/opt-out events
  if (settings.allowPIISharing !== undefined) {
    await db.collection('consentEvents').add({
      userId,
      eventType: settings.allowPIISharing ? 'pii_opt_in' : 'pii_opt_out',
      timestamp: Date.now()
    });
  }
}
```

**UI Component:**
```typescript
// components/settings/ai-settings.tsx

import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription } from '@/components/ui/alert';

export function AISettings() {
  const [allowPIISharing, setAllowPIISharing] = useState(false);

  const handleToggle = async (checked: boolean) => {
    setAllowPIISharing(checked);
    await updateAISettings(userId, { allowPIISharing: checked });
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="space-y-0.5">
          <Label htmlFor="pii-sharing">
            Share detailed case information with AI
          </Label>
          <p className="text-sm text-muted-foreground">
            Enable to share case narratives and details for more personalized responses.
            Personal information will be filtered before sending to AI.
          </p>
        </div>
        <Switch
          id="pii-sharing"
          checked={allowPIISharing}
          onCheckedChange={handleToggle}
        />
      </div>

      {allowPIISharing && (
        <Alert>
          <AlertDescription>
            When enabled, FairForm will share redacted case details with our AI provider
            to improve response quality. We automatically filter personal information like
            phone numbers, emails, and addresses before sending.
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
}
```

### Testing

**Test Location:** `lib/ai/piiRedaction.test.ts`

**Test Suite:**
```typescript
describe('PIIRedactionService', () => {
  let service: PIIRedactionService;

  beforeEach(() => {
    service = new PIIRedactionService();
  });

  it('redacts SSN', () => {
    const result = service.redact('My SSN is 123-45-6789');
    expect(result.redactedContent).toBe('My SSN is [SSN]');
    expect(result.hasRedactions).toBe(true);
    expect(result.redactions[0].pattern).toBe('ssn');
  });

  it('redacts email addresses', () => {
    const result = service.redact('Contact me at john@example.com');
    expect(result.redactedContent).toBe('Contact me at [EMAIL]');
  });

  it('redacts phone numbers', () => {
    const result = service.redact('Call me at (555) 123-4567');
    expect(result.redactedContent).toBe('Call me at [PHONE]');
  });

  it('redacts multiple PII types', () => {
    const content = 'My email is john@example.com and phone is 555-1234';
    const result = service.redact(content);

    expect(result.redactedContent).toContain('[EMAIL]');
    expect(result.redactedContent).toContain('[PHONE]');
    expect(result.redactions.length).toBe(2);
  });

  it('respects minimum confidence level', () => {
    const content = 'IP: 192.168.1.1'; // Low confidence
    const result = service.redact(content, { minConfidence: 'medium' });

    expect(result.hasRedactions).toBe(false);
  });

  it('preserves length when requested', () => {
    const original = 'SSN: 123-45-6789';
    const result = service.redact(original, { preserveLength: true });

    expect(result.redactedContent.length).toBe(original.length);
  });

  it('detects PII without redaction', () => {
    const detection = service.detectPII('Email: test@example.com, Phone: 555-1234');

    expect(detection.hasPII).toBe(true);
    expect(detection.patterns).toContain('email');
    expect(detection.patterns).toContain('phone_us');
    expect(detection.confidence).toBe('high');
  });

  it('handles overlapping patterns', () => {
    const content = '123456789'; // Could match SSN or ZIP
    const result = service.redact(content);

    expect(result.hasRedactions).toBe(true);
    // Should redact as most specific/confident pattern
  });
});
```

### Source Tree
```
lib/ai/
├── piiRedaction.ts        # NEW: Redaction service
├── piiPatterns.ts         # NEW: PII pattern definitions
├── contextBuilder.ts      # MODIFIED: Add redaction integration
└── types.ts               # MODIFIED: Add redaction types

lib/db/
└── userSettings.ts        # MODIFIED: Add PII sharing preference

components/settings/
└── ai-settings.tsx        # NEW: AI settings UI

tests/
└── lib/ai/
    └── piiRedaction.test.ts # NEW: Redaction tests
```

### Configuration

**Environment Variables:**
```bash
# .env.local
DEFAULT_PII_REDACTION=true
PII_MIN_CONFIDENCE=medium
```

### Performance Considerations
- Regex operations are O(n) - efficient for typical content sizes
- Cache compiled regex patterns
- Consider streaming redaction for large content
- Monitor redaction performance metrics

### Dependencies
- Node.js crypto module for hashing
- Existing context builder and user settings
- Firebase Admin SDK for logging

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-13 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent*

### Debug Log References
_To be populated by dev agent*

### Completion Notes List
_To be populated by dev agent*

### File List
_To be populated by dev agent*

## QA Results
_To be populated by QA agent*
