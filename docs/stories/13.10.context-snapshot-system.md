# Story 13.10: Context Snapshot System

## Status
Draft

## Story
**As a** FairForm developer,
**I want** a context snapshot system that maintains small, structured context data,
**so that** AI prompts remain efficient while preserving important context information.

## Acceptance Criteria

1. Context snapshots are small, structured objects (<1KB) stored with sessions
2. Snapshots include case type, jurisdiction, current step, and user preferences
3. Snapshots use hash-based fingerprinting for change detection
4. System automatically updates snapshots when context changes
5. Snapshots are used for prompt caching and optimization
6. System handles snapshot validation and error recovery
7. Snapshots include metadata for debugging and monitoring
8. Unit tests cover snapshot creation, updates, and validation

## Tasks / Subtasks

- [ ] Task 1: Create context snapshot service (AC: 1, 2)
  - [ ] Create `lib/ai/contextSnapshot.ts`
  - [ ] Implement createSnapshot function
  - [ ] Add snapshot structure validation
  - [ ] Ensure snapshot size limits (<1KB)
  - [ ] Include required context fields

- [ ] Task 2: Implement hash-based fingerprinting (AC: 3)
  - [ ] Create generateSnapshotHash function
  - [ ] Use SHA-256 for consistent hashing
  - [ ] Include all relevant context fields in hash
  - [ ] Handle hash collision detection
  - [ ] Add hash validation utilities

- [ ] Task 3: Add automatic snapshot updates (AC: 4)
  - [ ] Monitor context changes (case updates, step changes)
  - [ ] Trigger snapshot regeneration on changes
  - [ ] Update session metadata with new snapshot
  - [ ] Handle concurrent update scenarios
  - [ ] Add change detection logic

- [ ] Task 4: Integrate with prompt caching (AC: 5)
  - [ ] Use snapshots for prompt cache keys
  - [ ] Implement cache invalidation on snapshot changes
  - [ ] Add cache hit/miss logging
  - [ ] Optimize cache performance
  - [ ] Handle cache size limits

- [ ] Task 5: Implement snapshot validation (AC: 6)
  - [ ] Add snapshot schema validation
  - [ ] Handle corrupted snapshot recovery
  - [ ] Implement snapshot migration for schema changes
  - [ ] Add snapshot integrity checks
  - [ ] Handle validation failures gracefully

- [ ] Task 6: Add monitoring and debugging (AC: 7)
  - [ ] Log snapshot creation and updates
  - [ ] Add snapshot size monitoring
  - [ ] Track snapshot performance metrics
  - [ ] Add debugging utilities for snapshot inspection
  - [ ] Monitor hash collision rates

- [ ] Task 7: Update session data model (AC: 1)
  - [ ] Add contextSnapshot field to AISession
  - [ ] Update session creation logic
  - [ ] Modify session update operations
  - [ ] Add snapshot versioning support
  - [ ] Handle backward compatibility

- [ ] Task 8: Create comprehensive tests (AC: 8)
  - [ ] Test snapshot creation with various contexts
  - [ ] Test hash generation and validation
  - [ ] Test automatic update triggers
  - [ ] Test error handling scenarios
  - [ ] Test performance with large datasets

## Dev Notes

### Architecture Context
[Source: docs/epic-13-unified-architecture-specification.md]

Context snapshots are **critical for performance** - they provide small, structured context data that enables efficient prompt caching and reduces AI token usage. The system uses **hash-based fingerprinting** to detect changes and optimize caching.

**Key Design Decisions:**
- Small, structured snapshots (<1KB)
- Hash-based change detection
- Automatic updates on context changes
- Integration with prompt caching
- Comprehensive validation and error handling

### Snapshot Structure

**ContextSnapshot Interface:**
```typescript
interface ContextSnapshot {
  // Core case information
  caseType?: 'eviction' | 'small_claims' | 'family_law' | 'debt' | 'employment' | 'other_civil';
  jurisdiction?: string;
  currentStepOrder?: number;
  progressPct?: number;
  
  // User preferences
  userPrefs?: {
    aiParticipation?: boolean;
    timeZone?: string;
    tone?: 'formal' | 'friendly' | 'helpful';
    complexity?: 'simple' | 'detailed';
  };
  
  // System metadata
  hash: string;              // SHA-256 hash of snapshot
  version: number;           // Snapshot schema version
  createdAt: number;         // Creation timestamp
  updatedAt: number;         // Last update timestamp
  size: number;              // Snapshot size in bytes
}
```

### Snapshot Creation

**Snapshot Generation:**
```typescript
import crypto from 'crypto';

function createContextSnapshot(context: PartialContext): ContextSnapshot {
  const snapshot: Omit<ContextSnapshot, 'hash' | 'size'> = {
    caseType: context.case?.caseType,
    jurisdiction: context.case?.jurisdiction,
    currentStepOrder: context.case?.currentStepOrder,
    progressPct: context.case?.progressPct,
    userPrefs: context.user?.preferences,
    version: 1,
    createdAt: Date.now(),
    updatedAt: Date.now()
  };
  
  // Generate hash
  const hash = generateSnapshotHash(snapshot);
  
  // Calculate size
  const size = JSON.stringify(snapshot).length;
  
  // Validate size limit
  if (size > 1024) { // 1KB limit
    throw new Error('Context snapshot exceeds size limit');
  }
  
  return {
    ...snapshot,
    hash,
    size
  };
}

function generateSnapshotHash(snapshot: Omit<ContextSnapshot, 'hash' | 'size'>): string {
  // Create deterministic hash from snapshot data
  const hashData = {
    caseType: snapshot.caseType,
    jurisdiction: snapshot.jurisdiction,
    currentStepOrder: snapshot.currentStepOrder,
    progressPct: snapshot.progressPct,
    userPrefs: snapshot.userPrefs,
    version: snapshot.version
  };
  
  return crypto
    .createHash('sha256')
    .update(JSON.stringify(hashData))
    .digest('hex');
}
```

### Automatic Updates

**Change Detection:**
```typescript
interface ContextChangeEvent {
  type: 'case_update' | 'step_change' | 'user_pref_change';
  sessionId: string;
  oldSnapshot: ContextSnapshot;
  newContext: PartialContext;
  timestamp: number;
}

class ContextSnapshotManager {
  private updateQueue = new Map<string, ContextSnapshot>();
  
  async handleContextChange(event: ContextChangeEvent): Promise<void> {
    const { sessionId, oldSnapshot, newContext } = event;
    
    // Create new snapshot
    const newSnapshot = createContextSnapshot(newContext);
    
    // Check if snapshot actually changed
    if (newSnapshot.hash === oldSnapshot.hash) {
      return; // No change needed
    }
    
    // Queue snapshot update
    this.updateQueue.set(sessionId, newSnapshot);
    
    // Process update queue
    await this.processUpdateQueue();
  }
  
  private async processUpdateQueue(): Promise<void> {
    const updates = Array.from(this.updateQueue.entries());
    this.updateQueue.clear();
    
    for (const [sessionId, snapshot] of updates) {
      try {
        await aiSessionsRepo.updateContextSnapshot(sessionId, snapshot);
        console.log(`Updated context snapshot for session ${sessionId}`);
      } catch (error) {
        console.error(`Failed to update snapshot for session ${sessionId}:`, error);
        // Re-queue failed updates
        this.updateQueue.set(sessionId, snapshot);
      }
    }
  }
}
```

### Integration with Prompt Caching

**Cache Key Generation:**
```typescript
interface PromptCacheKey {
  sessionId: string;
  contextHash: string;
  promptType: 'system' | 'user' | 'context';
  model: string;
}

function generateCacheKey(
  sessionId: string,
  snapshot: ContextSnapshot,
  promptType: string,
  model: string = 'gpt-4o-mini'
): string {
  return `${sessionId}:${snapshot.hash}:${promptType}:${model}`;
}

class PromptCache {
  private cache = new Map<string, CachedPrompt>();
  
  get(key: PromptCacheKey): CachedPrompt | null {
    const cacheKey = generateCacheKey(key.sessionId, key.contextHash, key.promptType, key.model);
    return this.cache.get(cacheKey) || null;
  }
  
  set(key: PromptCacheKey, prompt: string, ttl: number = 300000): void { // 5 minutes
    const cacheKey = generateCacheKey(key.sessionId, key.contextHash, key.promptType, key.model);
    
    this.cache.set(cacheKey, {
      prompt,
      createdAt: Date.now(),
      expiresAt: Date.now() + ttl
    });
  }
  
  invalidate(sessionId: string, oldHash: string): void {
    const keysToDelete = Array.from(this.cache.keys()).filter(key => 
      key.includes(sessionId) && key.includes(oldHash)
    );
    
    keysToDelete.forEach(key => this.cache.delete(key));
  }
}
```

### Snapshot Validation

**Validation Schema:**
```typescript
import { z } from 'zod';

const ContextSnapshotSchema = z.object({
  caseType: z.enum(['eviction', 'small_claims', 'family_law', 'debt', 'employment', 'other_civil']).optional(),
  jurisdiction: z.string().max(100).optional(),
  currentStepOrder: z.number().min(0).max(1000).optional(),
  progressPct: z.number().min(0).max(100).optional(),
  userPrefs: z.object({
    aiParticipation: z.boolean().optional(),
    timeZone: z.string().max(50).optional(),
    tone: z.enum(['formal', 'friendly', 'helpful']).optional(),
    complexity: z.enum(['simple', 'detailed']).optional()
  }).optional(),
  hash: z.string().length(64), // SHA-256 hex string
  version: z.number().min(1),
  createdAt: z.number().positive(),
  updatedAt: z.number().positive(),
  size: z.number().max(1024) // 1KB limit
});

function validateSnapshot(snapshot: unknown): ContextSnapshot {
  try {
    return ContextSnapshotSchema.parse(snapshot);
  } catch (error) {
    throw new Error(`Invalid context snapshot: ${error.message}`);
  }
}
```

### Error Recovery

**Snapshot Recovery:**
```typescript
class SnapshotRecovery {
  async recoverCorruptedSnapshot(sessionId: string): Promise<ContextSnapshot> {
    try {
      // Attempt to rebuild snapshot from current context
      const session = await aiSessionsRepo.getSession(sessionId);
      const context = await buildContext(session.userId, session.caseId, sessionId);
      
      const newSnapshot = createContextSnapshot(context);
      
      // Update session with recovered snapshot
      await aiSessionsRepo.updateContextSnapshot(sessionId, newSnapshot);
      
      console.log(`Recovered snapshot for session ${sessionId}`);
      return newSnapshot;
      
    } catch (error) {
      console.error(`Failed to recover snapshot for session ${sessionId}:`, error);
      
      // Return minimal fallback snapshot
      return createFallbackSnapshot(sessionId);
    }
  }
  
  private createFallbackSnapshot(sessionId: string): ContextSnapshot {
    return {
      caseType: undefined,
      jurisdiction: undefined,
      currentStepOrder: undefined,
      progressPct: undefined,
      userPrefs: undefined,
      hash: 'fallback',
      version: 1,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      size: 100
    };
  }
}
```

### Source Tree
```
lib/ai/
├── contextSnapshot.ts     # NEW: Snapshot service
├── contextBuilder.ts      # EXISTING: From Story 13.3
├── types.ts              # MODIFIED: Add snapshot types
└── schemas.ts            # MODIFIED: Add snapshot schema

lib/db/
└── aiSessionsRepo.ts     # MODIFIED: Add snapshot support
```

### Integration Points

**Context Builder Integration:**
```typescript
// In contextBuilder.ts
async function buildContextWithSnapshot(
  userId: string,
  caseId?: string,
  sessionId?: string
): Promise<AIPromptContext> {
  // Get or create session
  const session = sessionId 
    ? await aiSessionsRepo.getSession(sessionId)
    : await aiSessionsRepo.createSession({ userId, caseId });
  
  // Get current snapshot
  let snapshot = session.contextSnapshot;
  
  // Validate and potentially recover snapshot
  if (!snapshot || !validateSnapshot(snapshot)) {
    snapshot = await snapshotRecovery.recoverCorruptedSnapshot(session.id);
  }
  
  // Build context using snapshot
  const context = buildContextFromSnapshot(snapshot, userId, caseId);
  
  return context;
}
```

### Monitoring and Debugging

**Snapshot Metrics:**
```typescript
interface SnapshotMetrics {
  totalSnapshots: number;
  averageSize: number;
  hashCollisions: number;
  updateFrequency: number;
  errorRate: number;
  cacheHitRate: number;
}

class SnapshotMonitor {
  private metrics: SnapshotMetrics = {
    totalSnapshots: 0,
    averageSize: 0,
    hashCollisions: 0,
    updateFrequency: 0,
    errorRate: 0,
    cacheHitRate: 0
  };
  
  recordSnapshotCreation(snapshot: ContextSnapshot): void {
    this.metrics.totalSnapshots++;
    this.metrics.averageSize = 
      (this.metrics.averageSize * (this.metrics.totalSnapshots - 1) + snapshot.size) / 
      this.metrics.totalSnapshots;
  }
  
  recordHashCollision(): void {
    this.metrics.hashCollisions++;
  }
  
  getMetrics(): SnapshotMetrics {
    return { ...this.metrics };
  }
}
```

### Testing

**Test Location:** `lib/ai/contextSnapshot.test.ts`

**Test Coverage:**
- Snapshot creation with various contexts
- Hash generation and validation
- Automatic update triggers
- Error recovery scenarios
- Performance with large datasets
- Cache integration

**Example Test:**
```typescript
describe('contextSnapshot', () => {
  it('creates valid snapshot with size limit', () => {
    const context = {
      case: {
        caseType: 'small_claims',
        jurisdiction: 'Los Angeles County',
        currentStepOrder: 2,
        progressPct: 50
      },
      user: {
        preferences: {
          tone: 'friendly',
          complexity: 'simple'
        }
      }
    };
    
    const snapshot = createContextSnapshot(context);
    
    expect(snapshot.size).toBeLessThanOrEqual(1024);
    expect(snapshot.hash).toHaveLength(64);
    expect(snapshot.caseType).toBe('small_claims');
  });
  
  it('detects changes and updates hash', () => {
    const context1 = { case: { caseType: 'eviction' } };
    const context2 = { case: { caseType: 'small_claims' } };
    
    const snapshot1 = createContextSnapshot(context1);
    const snapshot2 = createContextSnapshot(context2);
    
    expect(snapshot1.hash).not.toBe(snapshot2.hash);
  });
});
```

### Performance Considerations
- Keep snapshots under 1KB
- Use efficient hashing algorithms
- Implement snapshot compression if needed
- Monitor snapshot update frequency
- Cache frequently accessed snapshots

### Dependencies
- crypto (Node.js built-in)
- aiSessionsRepo from Story 13.1
- contextBuilder from Story 13.3
- Zod for validation (existing)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-13 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent*

### Debug Log References
_To be populated by dev agent*

### Completion Notes List
_To be populated by dev agent*

### File List
_To be populated by dev agent*

## QA Results
_To be populated by QA agent*
